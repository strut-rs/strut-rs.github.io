---
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {ShellArgument, ShellCommand, ShellOutput, ShellPrompt, ShellVariable, LogMuted, LogInfo, LogSuccess, LogMain} from '@site/src/components/Highlight';
import Terminal from '@site/src/components/Terminal';

# Quickstart

Let’s learn Strut with an example.

[crates-io-config]: https://crates.io/crates/config
[crates-io-tracing]: https://crates.io/crates/tracing

## Strut dependency

Create a binary crate and add the `strut` dependency:

```bash
cargo new demo-app && cd demo-app
cargo add strut
```

Write a simple main function:

```rust title="src/main.rs"
use strut::AppConfig;

#[strut::main]
async fn main() {
    let config = AppConfig::get();

    println!("Running {}...", config.name());
}
```

Run the application with `cargo run`:

<Terminal>
    <ShellPrompt>$</ShellPrompt>
    {" "}
    <ShellCommand>cargo</ShellCommand>
    {" "}
    <ShellArgument>run</ShellArgument>

    {"\n"}<ShellOutput>Running app...</ShellOutput>
</Terminal>

Impressive, right?
Just kidding, it gets better.

The application name (same as everything in `AppConfig`) has a reasonable default.

## Add configuration

Let’s configure the name explicitly (under the hood, the [`config`][crates-io-config] crate is used):

<Tabs>
    <TabItem value="YAML">
        ```yaml title="config/app.yaml"
        name: app-backend
        ```
    </TabItem>
    <TabItem value="TOML">
        ```toml title="config/app.toml"
        name = "app-backend"
        ```
    </TabItem>
</Tabs>

Now, when we `cargo run`, the output is:

<Terminal>
    <ShellPrompt>$</ShellPrompt>
    {" "}
    <ShellCommand>cargo</ShellCommand>
    {" "}
    <ShellArgument>run</ShellArgument>

    {"\n"}<ShellOutput>Running app-backend...</ShellOutput>
</Terminal>

## Override configuration

We can also set/override all config entries with environment variables:

```bash
APP_NAME=custom-app cargo run
```

<Terminal>
    <ShellPrompt>$</ShellPrompt>
    {" "}
    <ShellVariable>APP_NAME=custom-app</ShellVariable>
    {" "}
    <ShellCommand>cargo</ShellCommand>
    {" "}
    <ShellArgument>run</ShellArgument>

    {"\n"}<ShellOutput>Running custom-app...</ShellOutput>
</Terminal>

Nothing too exciting so far.

## Example component

The bulk of Strut’s usefulness comes from components.
Components are enabled via feature flags.

### Add `tracing` component

Most applications benefit from logging and tracing.
The `tracing` feature pulls and pre-configures the [`tracing`][crates-io-tracing] crate.

```bash
cargo add strut --features tracing
```

Change the main function to use `tracing` macros instead.
(We don’t depend on the `tracing` crate directly, but Strut re-exports important APIs for us.)

```rust title="src/main.rs"
use strut::AppConfig;
use strut::tracing::info;

#[strut::main]
async fn main() {
    let config = AppConfig::get();

    info!("Running {}...", config.name());
}
```

Now, `cargo run` outputs something more serious, and perhaps familiar:

<Terminal width='95%' wrap={true} fontSize='0.75em'>
    <ShellPrompt>$</ShellPrompt>
    {" "}
    <ShellCommand>cargo</ShellCommand>
    {" "}
    <ShellArgument>run</ShellArgument>

    {"\n"}
    <LogMuted>1969-10-29T22:30:00.010227Z</LogMuted>
    {"  "}
    <LogInfo>INFO</LogInfo>
    {" "}
    <LogMain>ThreadId(01)</LogMain>
    {" "}
    <LogMuted>strut::launchpad::wiring::preflight:</LogMuted>
    {" "}
    <LogMain>Starting app-backend with profile 'dev' (default replica, lifetime ID 'xbr-dwxn-klp')</LogMain>

    {"\n"}
    <LogMuted>1969-10-29T22:30:00.010296Z</LogMuted>
    {"  "}
    <LogInfo>INFO</LogInfo>
    {" "}
    <LogMain>ThreadId(01)</LogMain>
    {" "}
    <LogMuted>demo_app:</LogMuted>
    {" "}
    <LogMain>Running app-backend...</LogMain>

    {"\n"}
    <LogMuted>1969-10-29T22:30:00.010308Z</LogMuted>
    {"  "}
    <LogInfo>INFO</LogInfo>
    {" "}
    <LogMain>ThreadId(01)</LogMain>
    {" "}
    <LogMuted>strut_core::context:</LogMuted>
    {" "}
    <LogMain>Terminating application context</LogMain>

    {"\n"}
    <LogMuted>1969-10-29T22:30:00.010325Z</LogMuted>
    {"  "}
    <LogInfo>INFO</LogInfo>
    {" "}
    <LogMain>ThreadId(01)</LogMain>
    {" "}
    <LogMuted>strut_core::spindown::registry:</LogMuted>
    {" "}
    <LogMain>Spindown initiated</LogMain>

    {"\n"}
    <LogMuted>1969-10-29T22:30:00.010352Z</LogMuted>
    {"  "}
    <LogInfo>INFO</LogInfo>
    {" "}
    <LogMain>ThreadId(01)</LogMain>
    {" "}
    <LogMuted>strut_core::spindown::registry:</LogMuted>
    {" "}
    <LogMain>Spindown completed</LogMain>
</Terminal>

A few things to notice:

- Strut maintains an application context which is terminated on shutdown.
- A spindown procedure is baked in, where long-running services have a chance to free resources.

### Add `prod` configuration

The tracing output is nice and human-readable.
But in `prod` we almost certainly need structured logging.
Let’s add that:

```bash
cargo add strut --features tracing-json
```

Add a `prod`-specific config file following the naming convention:

<Tabs>
    <TabItem value="YAML">
        ```yaml title="config/app.prod.yaml"
        tracing:
            flavor: json # “flavour” works too :)
        ```
    </TabItem>
    <TabItem value="TOML">
        ```toml title="config/app.prod.toml"
        [tracing]
        flavor = "json" # “flavour” works too :)
        ```
    </TabItem>
</Tabs>

Nothing will change for `cargo run`.
But when we set the runtime profile to `prod`:

```bash
APP_PROFILE=prod cargo run
```

The output is now fit for streaming structured logs:

<Terminal width='95%' wrap={true} fontSize='0.75em'>
    <ShellPrompt>$</ShellPrompt>
    {" "}
    <ShellCommand>cargo</ShellCommand>
    {" "}
    <ShellArgument>run</ShellArgument>

    {"\n"}<LogMuted>{'{"timestamp":"1969-10-29T22:30:00.937059Z","level":"INFO","fields":{"message":"Starting app-backend with profile \'prod\' (default replica, lifetime ID \'rli-dgff-ysd\')"},"target":"strut::launchpad::wiring::preflight","threadId":"ThreadId(1)"}'}</LogMuted>
    {"\n"}<LogMuted>{'{"timestamp":"1969-10-29T22:30:00.937169Z","level":"INFO","fields":{"message":"Running app-backend..."},"target":"strut_dummy","threadId":"ThreadId(1)"}'}</LogMuted>
    {"\n"}<LogMuted>{'{"timestamp":"1969-10-29T22:30:00.937178Z","level":"INFO","fields":{"message":"Terminating application context"},"target":"strut_core::context","threadId":"ThreadId(1)"}'}</LogMuted>
    {"\n"}<LogMuted>{'{"timestamp":"1969-10-29T22:30:00.937186Z","level":"INFO","fields":{"message":"Spindown initiated"},"target":"strut_core::spindown::registry","threadId":"ThreadId(1)"}'}</LogMuted>
    {"\n"}<LogMuted>{'{"timestamp":"1969-10-29T22:30:00.937200Z","level":"INFO","fields":{"message":"Spindown completed"},"target":"strut_core::spindown::registry","threadId":"ThreadId(1)"}'}</LogMuted>
</Terminal>
