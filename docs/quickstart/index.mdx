---
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Terminal from '@site/src/components/Terminal';
import {Shell, Log} from '@site/src/components/Terminal/Highlight';

# Quickstart

Let’s learn Strut with an example.

[crates-io-config]: https://crates.io/crates/config
[crates-io-tracing]: https://crates.io/crates/tracing

## Strut dependency

Create a binary crate and add the `strut` dependency:

```bash
cargo new demo-app && cd demo-app
cargo add strut
```

Write a simple main function:

```rust title="src/main.rs"
use strut::AppConfig;

#[strut::main]
async fn main() {
    let config = AppConfig::get();

    println!("Running {}...", config.name());
}
```

Run the application with `cargo run`:

<Terminal>
    <Shell.Prompt>$</Shell.Prompt>
    {" "}
    <Shell.Command>cargo</Shell.Command>
    {" "}
    <Shell.Argument>run</Shell.Argument>

    {"\n"}<Shell.Output>Running app...</Shell.Output>
</Terminal>

Impressive, right?
Just kidding, it gets better.

The application name (same as everything in `AppConfig`) has a reasonable default.

## Add configuration

Let’s configure the name explicitly (under the hood, the [`config`][crates-io-config] crate is used):

<Tabs>
    <TabItem value="YAML">
        ```yaml title="config/app.yaml"
        name: app-backend
        ```
    </TabItem>
    <TabItem value="TOML">
        ```toml title="config/app.toml"
        name = "app-backend"
        ```
    </TabItem>
</Tabs>

Now, when we `cargo run`, the output is:

<Terminal>
    <Shell.Prompt>$</Shell.Prompt>
    {" "}
    <Shell.Command>cargo</Shell.Command>
    {" "}
    <Shell.Argument>run</Shell.Argument>

    {"\n"}<Shell.Output>Running app-backend...</Shell.Output>
</Terminal>

## Override configuration

We can also set/override all config entries with environment variables:

```bash
APP_NAME=custom-app cargo run
```

<Terminal>
    <Shell.Prompt>$</Shell.Prompt>
    {" "}
    <Shell.Variable>APP_NAME=custom-app</Shell.Variable>
    {" "}
    <Shell.Command>cargo</Shell.Command>
    {" "}
    <Shell.Argument>run</Shell.Argument>

    {"\n"}<Shell.Output>Running custom-app...</Shell.Output>
</Terminal>

Nothing too exciting so far.

## Example component

The bulk of Strut’s usefulness comes from components.
Components are enabled via feature flags.

### Add `tracing` component

Most applications benefit from logging and tracing.
The `tracing` feature pulls and pre-configures the [`tracing`][crates-io-tracing] crate.

```bash
cargo add strut --features tracing
```

Change the main function to use `tracing` macros instead.
(We don’t depend on the `tracing` crate directly, but Strut re-exports important APIs for us.)

```rust title="src/main.rs"
use strut::AppConfig;
use strut::tracing::info;

#[strut::main]
async fn main() {
    let config = AppConfig::get();

    info!("Running {}...", config.name());
}
```

Now, `cargo run` outputs something more serious, and perhaps familiar:

<Terminal width='95%' wrap={false} fontSize='0.75em'>
    <Shell.Prompt>$</Shell.Prompt>
    {" "}
    <Shell.Command>cargo</Shell.Command>
    {" "}
    <Shell.Argument>run</Shell.Argument>

    {"\n"}
    <Log.Muted>1969-10-29T22:30:00.010227Z</Log.Muted>
    {"  "}
    <Log.Info>INFO</Log.Info>
    {" "}
    <Log.Main>ThreadId(01)</Log.Main>
    {" "}
    <Log.Muted>strut::launchpad::wiring::preflight:</Log.Muted>
    {" "}
    <Log.Main>Starting app-backend with profile 'dev' (default replica, lifetime ID 'xbr-dwxn-klp')</Log.Main>

    {"\n"}
    <Log.Muted>1969-10-29T22:30:00.010296Z</Log.Muted>
    {"  "}
    <Log.Info>INFO</Log.Info>
    {" "}
    <Log.Main>ThreadId(01)</Log.Main>
    {" "}
    <Log.Muted>demo_app:</Log.Muted>
    {" "}
    <Log.Main>Running app-backend...</Log.Main>

    {"\n"}
    <Log.Muted>1969-10-29T22:30:00.010308Z</Log.Muted>
    {"  "}
    <Log.Info>INFO</Log.Info>
    {" "}
    <Log.Main>ThreadId(01)</Log.Main>
    {" "}
    <Log.Muted>strut_core::context:</Log.Muted>
    {" "}
    <Log.Main>Terminating application context</Log.Main>

    {"\n"}
    <Log.Muted>1969-10-29T22:30:00.010325Z</Log.Muted>
    {"  "}
    <Log.Info>INFO</Log.Info>
    {" "}
    <Log.Main>ThreadId(01)</Log.Main>
    {" "}
    <Log.Muted>strut_core::spindown::registry:</Log.Muted>
    {" "}
    <Log.Main>Spindown initiated</Log.Main>

    {"\n"}
    <Log.Muted>1969-10-29T22:30:00.010352Z</Log.Muted>
    {"  "}
    <Log.Info>INFO</Log.Info>
    {" "}
    <Log.Main>ThreadId(01)</Log.Main>
    {" "}
    <Log.Muted>strut_core::spindown::registry:</Log.Muted>
    {" "}
    <Log.Main>Spindown completed</Log.Main>
</Terminal>

A few things to notice:

- Strut maintains an application context which is terminated on shutdown.
- A spindown procedure is baked in, where long-running services have a chance to free resources.

### Add `prod` configuration

The tracing output is nice and human-readable.
But in `prod` we almost certainly need structured logging.
Let’s add that:

```bash
cargo add strut --features tracing-json
```

Add a `prod`-specific config file following the naming convention:

<Tabs>
    <TabItem value="YAML">
        ```yaml title="config/app.prod.yaml"
        tracing:
            flavor: json # “flavour” works too :)
        ```
    </TabItem>
    <TabItem value="TOML">
        ```toml title="config/app.prod.toml"
        [tracing]
        flavor = "json" # “flavour” works too :)
        ```
    </TabItem>
</Tabs>

Nothing will change for `cargo run`.
But when we set the runtime profile to `prod`:

```bash
APP_PROFILE=prod cargo run
```

The output is now fit for streaming structured logs:

<Terminal width='95%' wrap={true} fontSize='0.75em'>
    <Shell.Prompt>$</Shell.Prompt>
    {" "}
    <Shell.Command>cargo</Shell.Command>
    {" "}
    <Shell.Argument>run</Shell.Argument>

    {"\n"}<Log.Muted>{'{"timestamp":"1969-10-29T22:30:00.937059Z","level":"INFO","fields":{"message":"Starting app-backend with profile \'prod\' (default replica, lifetime ID \'rli-dgff-ysd\')"},"target":"strut::launchpad::wiring::preflight","threadId":"ThreadId(1)"}'}</Log.Muted>
    {"\n"}<Log.Muted>{'{"timestamp":"1969-10-29T22:30:00.937169Z","level":"INFO","fields":{"message":"Running app-backend..."},"target":"strut_dummy","threadId":"ThreadId(1)"}'}</Log.Muted>
    {"\n"}<Log.Muted>{'{"timestamp":"1969-10-29T22:30:00.937178Z","level":"INFO","fields":{"message":"Terminating application context"},"target":"strut_core::context","threadId":"ThreadId(1)"}'}</Log.Muted>
    {"\n"}<Log.Muted>{'{"timestamp":"1969-10-29T22:30:00.937186Z","level":"INFO","fields":{"message":"Spindown initiated"},"target":"strut_core::spindown::registry","threadId":"ThreadId(1)"}'}</Log.Muted>
    {"\n"}<Log.Muted>{'{"timestamp":"1969-10-29T22:30:00.937200Z","level":"INFO","fields":{"message":"Spindown completed"},"target":"strut_core::spindown::registry","threadId":"ThreadId(1)"}'}</Log.Muted>
</Terminal>
