"use strict";(self.webpackChunkstrut_home=self.webpackChunkstrut_home||[]).push([[294],{3303:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"profile/index","title":"Profile","description":"[docs-config-file-naming-convention]: /docs/config#file-naming-convention","source":"@site/docs/05_profile/index.mdx","sourceDirName":"05_profile","slug":"/profile","permalink":"/docs/profile","draft":false,"unlisted":false,"editUrl":"https://github.com/strut-rs/strut-rs.github.io/edit/main/docs/05_profile/index.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"slug":"/profile","title":"Profile"},"sidebar":"docs","previous":{"title":"Configuration","permalink":"/docs/config"},"next":{"title":"Components","permalink":"/docs/components"}}');var t=i(4848),o=i(8453);const s={sidebar_position:4,slug:"/profile",title:"Profile"},c="Runtime profile",l={},a=[{value:"Profiles",id:"profiles",level:2},{value:"Quickstart",id:"quickstart",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"runtime-profile",children:"Runtime profile"})}),"\n",(0,t.jsxs)(n.p,{children:["Strut maintains the familiar concept of runtime profiles.\nProfiles are represented by the ",(0,t.jsx)(n.a,{href:"https://docs.rs/strut-core/latest/strut_core/enum.AppProfile.html",children:(0,t.jsx)(n.code,{children:"AppProfile"})})," enumeration."]}),"\n",(0,t.jsxs)(n.p,{children:["At runtime, exactly one profile is ",(0,t.jsx)(n.strong,{children:"active"}),".\nThere is no auto-detection mechanism for the active profile.\nInstead, active profile is specified in the environment variable ",(0,t.jsx)(n.code,{children:"APP_PROFILE"}),"."]}),"\n",(0,t.jsxs)(n.admonition,{title:"No automated inference?",type:"note",children:[(0,t.jsxs)(n.p,{children:["In the Rust world, there is no reliable, built-in way to infer the active runtime profile from the environment.\nFor one, Rust & Cargo don\u2019t expose any ",(0,t.jsx)(n.em,{children:"runtime"})," markers of test execution.\nThis is presumably done to discourage test-specific behavior and instead test actual production code."]}),(0,t.jsxs)(n.p,{children:["This leaves us with a requirement to use something like ",(0,t.jsx)(n.code,{children:"APP_PROFILE=test cargo test ..."}),", for example to plug an in-memory database during testing."]}),(0,t.jsx)(n.p,{children:"If in the future the situation changes, Strut may introduce inference logic."})]}),"\n",(0,t.jsx)(n.h2,{id:"profiles",children:"Profiles"}),"\n",(0,t.jsx)(n.p,{children:"There are three well-recognized profiles:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Prod"})," (",(0,t.jsx)(n.code,{children:'"prod"'}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Dev"})," (",(0,t.jsx)(n.code,{children:'"dev"'}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Test"})," (",(0,t.jsx)(n.code,{children:'"test"'}),")"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Dev"})," is the global default when no profile is specified."]}),"\n",(0,t.jsxs)(n.p,{children:["Custom named profiles are supported through the ",(0,t.jsx)(n.code,{children:"Custom"})," case.\nAny custom profile must be a string that is:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"ASCII alphanumeric (other characters are ignored)."}),"\n",(0,t.jsx)(n.li,{children:"No longer than 7 characters (extra characters are truncated)."}),"\n",(0,t.jsx)(n.li,{children:"Lowercase (uppercase characters are converted)."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"quickstart",children:"Quickstart"}),"\n",(0,t.jsxs)(n.p,{children:["Currently, Strut uses the active runtime profile only to establish ",(0,t.jsx)(n.a,{href:"/docs/config#file-naming-convention",children:"which profile-specific config files to load"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Client code can make runtime choices based on the active profile as such:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use strut::core::AppProfile;\n\nmatch AppProfile::active() {\n    AppProfile::Prod => println!("We are in prod"),\n    AppProfile::Dev => println!("We are in dev"),\n    AppProfile::Test => println!("We are in test"),\n    AppProfile::Custom(name) => {\n        match name.as_str() {\n            "preprod" => println!("We are in preprod"),\n            other => println!("We are in {}", other),\n        };\n    }\n};\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>c});var r=i(6540);const t={},o=r.createContext(t);function s(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);